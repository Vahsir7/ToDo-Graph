// --- Constants ---
const ME_NODE_ID = 'me_node';
const CATEGORY_NODE_PREFIX = 'cat_';
const TASK_NODE_PREFIX = 'task_'; // Actually using task ID directly

// --- Global Variables ---
let tasks = {}; // { id: { title: '', categoryId: '', completed: false, dependencies: [], dueDate: 'YYYY-MM-DD' | null } }
let categories = {}; // { id: 'Category Name' }

// --- Utility Functions ---
const generateId = () => `task_${Date.now()}_${Math.random().toString(36).substring(2, 7)}`;
const generateCatId = (name) => CATEGORY_NODE_PREFIX + name.toLowerCase().replace(/[^a-z0-9]+/g, '_').replace(/^_|_$/g, '');
const formatDate = (dateString, options = { month: 'short', day: 'numeric' }) => {
    if (!dateString) return '';
    try {
        // Handle potential timezone issues by ensuring we parse as local date
        const [year, month, day] = dateString.split('-').map(Number);
        const date = new Date(year, month - 1, day); // Month is 0-indexed
        return date.toLocaleDateString(undefined, options);
    } catch (e) {
        console.error("Error formatting date:", dateString, e);
        return dateString; // Fallback to original string
    }
};
const getISODate = (dateString) => { // Ensure date is in YYYY-MM-DD for input[type=date]
     if (!dateString) return '';
     try {
        // Check if it's already in YYYY-MM-DD format
        if (/^\d{4}-\d{2}-\d{2}$/.test(dateString)) {
            return dateString;
        }
        // Attempt to parse other formats (might need refinement)
        const date = new Date(dateString);
        // Check if the date is valid after parsing
        if (isNaN(date.getTime())) {
             console.warn("Could not parse date for ISO conversion:", dateString);
             return ''; // Return empty if parsing fails
        }
        // Format to YYYY-MM-DD, handling timezone offset
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0'); // Month is 0-indexed
        const day = String(date.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
     } catch { return ''; }
}

// --- Data Persistence ---
function loadData() {
    const storedTasks = localStorage.getItem('tasks');
    const storedCategories = localStorage.getItem('categories');

    tasks = storedTasks ? JSON.parse(storedTasks) : {};
    // Define default categories with proper IDs generated by the function
    const defaultCategoriesRaw = ['IIT', 'Coding', 'NIT', 'Projects'];
    const defaultCategories = defaultCategoriesRaw.reduce((acc, name) => {
        acc[generateCatId(name)] = name;
        return acc;
    }, {});

    categories = storedCategories ? JSON.parse(storedCategories) : defaultCategories;

    // Ensure default categories exist & ID format is correct
    let dataChanged = false;
    Object.entries(defaultCategories).forEach(([defaultId, defaultName]) => {
        const nameLower = defaultName.toLowerCase();
        let foundId = null;
        // Check if a category with the same name exists (case-insensitive)
        for (const id in categories) {
            if (categories[id].toLowerCase() === nameLower) {
                foundId = id;
                break;
            }
        }

        if (!foundId) { // Add if name doesn't exist at all
             categories[defaultId] = defaultName;
             console.log(`Adding default category: ${defaultName} (ID: ${defaultId})`);
             dataChanged = true;
        } else if (foundId !== defaultId) { // Name exists but with a different (potentially old/incorrect) ID format
             console.warn(`Migrating category "${defaultName}" from old ID ${foundId} to standard ID ${defaultId}`);
             // Update tasks using the old category ID
             Object.values(tasks).forEach(task => {
                 if (task.categoryId === foundId) {
                     task.categoryId = defaultId;
                     dataChanged = true;
                 }
             });
             // Use the standard ID and name, remove the old entry
             categories[defaultId] = categories[foundId]; // Keep the potentially user-modified name casing
             delete categories[foundId];
             dataChanged = true;
        } else {
             // ID matches the default generated ID, ensure the name casing is the default one if needed
             // (usually not necessary, allow user casing)
             // categories[defaultId] = defaultName; // Uncomment to enforce default casing
        }
    });

    console.log("Data loaded:", { tasks, categories });

    // Save immediately after load ONLY if corrections were made during loading
    if (dataChanged) {
        console.log("Saving data after corrections during load.");
        saveData();
    }
}

function saveData() {
    try {
        localStorage.setItem('tasks', JSON.stringify(tasks));
        localStorage.setItem('categories', JSON.stringify(categories));
        console.log("Data saved.");
        // Dispatch event for other tabs/windows
        window.dispatchEvent(new CustomEvent('dataUpdated'));
    } catch (e) {
        console.error("Error saving data to localStorage:", e);
        // Potentially alert the user if storage is full or disabled
        alert("Could not save data. Local storage might be full or disabled.");
    }
}

// --- Task & Category Management Functions ---
function addTask(title, categoryId, dueDate = null) {
    if (!title || !categoryId || !categories[categoryId]) {
        console.error("Invalid task data provided (title missing, or categoryId invalid/missing):", {title, categoryId, dueDate});
        return null; // Indicate failure
    }
    const taskId = generateId();
    tasks[taskId] = {
        title: title,
        categoryId: categoryId,
        completed: false,
        dependencies: [], // Initialize as empty array
        dueDate: dueDate ? getISODate(dueDate) : null // Ensure dueDate is stored as YYYY-MM-DD
    };
    saveData();
    return taskId; // Return new task ID
}

function updateTask(taskId, updatedData) {
     if (!tasks[taskId]) return false;
     // Only update allowed fields
     const allowedUpdates = ['title', 'categoryId', 'dueDate', 'completed', 'dependencies'];
     let changed = false;
     Object.keys(updatedData).forEach(key => {
         if (allowedUpdates.includes(key)) {
            let newValue = updatedData[key];
             // Basic validation
             if (key === 'categoryId' && (!newValue || !categories[newValue])) {
                 console.warn(`Invalid category ID "${newValue}" provided for task update. Ignoring.`);
                 return; // Skip this update key
             }
             if (key === 'dependencies' && !Array.isArray(newValue)) {
                 console.warn(`Dependencies must be an array. Ignoring.`);
                 return; // Skip this update key
             }
             if (key === 'dueDate') {
                 // Ensure it's either null or valid YYYY-MM-DD
                 newValue = newValue ? getISODate(newValue) : null;
             }

             // Update only if the value has actually changed
             if (tasks[taskId][key] !== newValue) {
                // Special handling for dependencies array comparison if needed (deep equal)
                if(key === 'dependencies' && JSON.stringify(tasks[taskId][key]) === JSON.stringify(newValue)) {
                    return; // Don't mark as changed if arrays are equivalent
                }
                tasks[taskId][key] = newValue;
                changed = true;
             }
         }
     });
     if (changed) {
        saveData();
     }
     return true; // Indicate success (even if nothing changed)
}


function deleteTask(taskId) {
    if (!tasks[taskId]) return false;

    // Confirmation logic should be handled in the UI before calling this
    const taskTitle = tasks[taskId].title;
    delete tasks[taskId];

    // Remove this task from other tasks' dependency lists
    Object.values(tasks).forEach(task => {
        const index = task.dependencies.indexOf(taskId);
        if (index > -1) {
            task.dependencies.splice(index, 1);
        }
        // Alternative: task.dependencies = task.dependencies.filter(depId => depId !== taskId);
    });

    saveData();
    console.log(`Task "${taskTitle}" deleted.`);
    return true;
}

function toggleTaskComplete(taskId) {
    const task = tasks[taskId];
    if (!task) return false; // Task not found

    const markAsComplete = !task.completed;

    if (markAsComplete) {
        // Check dependencies
        const unmetDependencies = task.dependencies.filter(depId => tasks[depId] && !tasks[depId].completed);
        if (unmetDependencies.length > 0) {
            const unmetNames = unmetDependencies.map(depId => tasks[depId]?.title || `Unknown Task (ID: ${depId})`).join(', ');
            // Return error message to be displayed by UI
            return `Cannot complete "${task.title}". Prerequisite tasks unmet:\n- ${unmetNames.replace(/, /g, '\n- ')}`;
        }
    }

    task.completed = markAsComplete;
    saveData();
    return true; // Indicate success
}

function addCategory(name) {
    if (!name) return null;
    const lowerCaseName = name.trim().toLowerCase();
    if (!lowerCaseName) return null; // Check after trimming

    if (Object.values(categories).some(existingName => existingName.toLowerCase() === lowerCaseName)) {
        return `Category "${name.trim()}" already exists.`; // Return error message
    }

    let catId = generateCatId(name.trim());
    // Ensure ID uniqueness (rarely needed with prefix, but good practice)
    let count = 1;
    const baseId = catId;
    while (categories[catId]) {
        console.warn(`Generated category ID ${catId} already exists, appending count.`);
        catId = `${baseId}_${count++}`;
    }

    categories[catId] = name.trim(); // Store trimmed name
    saveData();
    return catId; // Return new category ID
}

function updateCategory(categoryId, newName) {
    const trimmedNewName = newName.trim();
    if (!categories[categoryId] || !trimmedNewName) return false;
     // Check if new name already exists (case-insensitive), excluding the current category
     const lowerCaseNewName = trimmedNewName.toLowerCase();
     if (Object.entries(categories).some(([id, name]) => id !== categoryId && name.toLowerCase() === lowerCaseNewName)) {
         return `Category name "${trimmedNewName}" is already in use.`; // Return error message
     }
    categories[categoryId] = trimmedNewName; // Store trimmed name
    saveData();
    return true;
}

function deleteCategory(categoryId) {
    if (!categories[categoryId]) return false;
    // Cannot delete the 'Me' node equivalent if it were treated as a category
    if (categoryId === ME_NODE_ID) return "Cannot delete the central 'Me' node.";

    // Check if any tasks use this category
    const tasksUsingCategory = Object.entries(tasks).filter(([_, task]) => task.categoryId === categoryId);

    if (tasksUsingCategory.length > 0) {
        // Default behavior: Prevent deletion if tasks are assigned.
         return `Cannot delete category "${categories[categoryId]}". ${tasksUsingCategory.length} task(s) are using it. Please reassign or delete them first.`;

        // --- Alternative Option: Reassign tasks ---
        /*
        const otherCategoryIds = Object.keys(categories).filter(id => id !== categoryId);
        if (otherCategoryIds.length === 0) {
            return `Cannot delete the last category "${categories[categoryId]}". Create another category first.`;
        }
        const defaultCatId = otherCategoryIds[0]; // Reassign to the first available other category
        const categoryName = categories[categoryId]; // Get name before deleting
        tasksUsingCategory.forEach(([taskId, task]) => {
            task.categoryId = defaultCatId;
            console.log(`Reassigning task "${task.title}" from ${categoryName} to ${categories[defaultCatId]}`);
        });
        delete categories[categoryId];
        saveData();
        console.log(`Category "${categoryName}" deleted. ${tasksUsingCategory.length} tasks reassigned to "${categories[defaultCatId]}".`);
        return true;
        */
    } else {
        // No tasks using it, safe to delete
        const categoryName = categories[categoryId]; // Get name before deleting
        delete categories[categoryId];
        saveData();
         console.log(`Category "${categoryName}" deleted.`);
        return true;
    }
}


function addDependency(taskId, prerequisiteTaskId) {
     const task = tasks[taskId];
     if (!task || !tasks[prerequisiteTaskId]) return "Task or prerequisite not found.";
     if (taskId === prerequisiteTaskId) return "A task cannot depend on itself.";
     if (task.dependencies.includes(prerequisiteTaskId)) {
         console.log("Dependency already exists.");
         return true; // Indicate success even if it already exists
     };

     // Circular dependency check: Traverse prerequisites of the prerequisite task
     const checkCircular = (currentTaskId, targetTaskId, visited = new Set()) => {
         if (currentTaskId === targetTaskId) return true; // Cycle detected
         if (visited.has(currentTaskId)) return false; // Already checked this path
         visited.add(currentTaskId);

         const currentTask = tasks[currentTaskId];
         if (!currentTask || !currentTask.dependencies || currentTask.dependencies.length === 0) {
             return false; // No further dependencies
         }

         for (const depId of currentTask.dependencies) {
             if (checkCircular(depId, targetTaskId, new Set(visited))) { // Pass copy of visited set
                 return true;
             }
         }
         return false;
     };

     if (checkCircular(prerequisiteTaskId, taskId)) {
         return `Cannot add dependency: This would create a circular dependency involving "${tasks[prerequisiteTaskId].title}" and "${task.title}".`;
     }

     task.dependencies.push(prerequisiteTaskId);
     saveData();
     return true;
}

function removeDependency(taskId, prerequisiteTaskId) {
     const task = tasks[taskId];
     if (!task) return false; // Task not found
     const initialLength = task.dependencies.length;
     task.dependencies = task.dependencies.filter(depId => depId !== prerequisiteTaskId);
     if (task.dependencies.length < initialLength) {
         saveData();
         return true;
     }
     console.log("Attempted to remove a dependency that did not exist.");
     return false; // Dependency didn't exist
}

// --- Theme Management ---
function applyTheme(isDark) {
    const lightIcon = document.getElementById('theme-icon-light');
    const darkIcon = document.getElementById('theme-icon-dark');
    // Apply class to <html> element for Tailwind's dark: prefix
    if (isDark) {
        document.documentElement.classList.add('dark');
    } else {
        document.documentElement.classList.remove('dark');
    }
    // Apply icons visibility
    if (lightIcon && darkIcon) {
        lightIcon.classList.toggle('hidden', !isDark);
        darkIcon.classList.toggle('hidden', isDark);
    }
    // Apply class to body if needed for specific non-Tailwind CSS rules (less common now)
    // document.body.classList.toggle('dark', isDark);
}

function initializeTheme() {
    const themeToggleBtn = document.getElementById('theme-toggle');
    // 1. Check localStorage
    const savedTheme = localStorage.getItem('darkMode');
    let isDark;

    if (savedTheme !== null) {
        isDark = savedTheme === 'true';
    } else {
        // 2. Check prefers-color-scheme
        isDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
    }

    // Apply theme classes BEFORE rendering content to avoid FOUC
    applyTheme(isDark);

    if (themeToggleBtn) {
        themeToggleBtn.addEventListener('click', () => {
            // Toggle based on the current state of the <html> element
            const newIsDark = document.documentElement.classList.toggle('dark');
            localStorage.setItem('darkMode', newIsDark);
            applyTheme(newIsDark); // Update icons and potentially body class

            // Dispatch event for other components (like graph/calendar) to potentially re-render
            window.dispatchEvent(new CustomEvent('themeChanged', { detail: { isDark: newIsDark } }));
        });
    }

    // Optional: Listen for system theme changes
    const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
    try {
        mediaQuery.addEventListener('change', (e) => {
            // Only apply system change if localStorage is not set
            if (localStorage.getItem('darkMode') === null) {
                applyTheme(e.matches);
                // Dispatch event if needed
                 window.dispatchEvent(new CustomEvent('themeChanged', { detail: { isDark: e.matches } }));
            }
        });
    } catch (e) { // Safari < 14 might not support addEventListener
        try {
             mediaQuery.addListener((e) => { // Deprecated but fallback
                 if (localStorage.getItem('darkMode') === null) {
                     applyTheme(e.matches);
                      window.dispatchEvent(new CustomEvent('themeChanged', { detail: { isDark: e.matches } }));
                 }
             });
        } catch (e2) {
             console.error("Theme change listener not supported:", e2);
        }
    }
}


// --- Navbar Active State ---
function setActiveNav(currentPageFilename) {
    // Select links within the specific navbar structure
    const navLinks = document.querySelectorAll('.navbar div a'); // Target links within the div inside .navbar
    navLinks.forEach(link => {
        link.classList.remove('active');
        // Get the filename from the href attribute
        const linkFilename = link.getAttribute('href').split('/').pop();
        if (linkFilename === currentPageFilename) {
            link.classList.add('active');
        }
    });
}

// --- Initial Load ---
// Load data as soon as the script runs
loadData();

// Theme initialization and UI setup should happen AFTER the DOM is loaded
// Ensure initializeTheme() and setActiveNav() are called within
// document.addEventListener('DOMContentLoaded', ...) in each HTML file.